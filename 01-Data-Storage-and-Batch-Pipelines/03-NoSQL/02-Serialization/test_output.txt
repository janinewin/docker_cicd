============================= test session starts ==============================
platform linux -- Python 3.8.10, pytest-7.1.2, pluggy-1.0.0 -- /home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/bin/python
cachedir: .pytest_cache
rootdir: /home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization
plugins: anyio-3.6.1
collecting ... collected 8 items

tests/test_all.py::test_there_is_a_csv_file FAILED                       [ 12%]
tests/test_all.py::test_import_pandas PASSED                             [ 25%]
tests/test_all.py::test_load_file FAILED                                 [ 37%]
tests/test_all.py::test_columns FAILED                                   [ 50%]
tests/test_all.py::test_size FAILED                                      [ 62%]
tests/test_all.py::test_countries FAILED                                 [ 75%]
tests/test_all.py::test_to_parquet FAILED                                [ 87%]
tests/test_all.py::test_parquetted FAILED                                [100%]

=================================== FAILURES ===================================
___________________________ test_there_is_a_csv_file ___________________________

    def test_there_is_a_csv_file():
        from lwserialization import rural
>       assert os.path.isfile(rural.get_rural_csv_fp()), "file API-rural.csv not found under data/"
E       AssertionError: file API-rural.csv not found under data/
E       assert False
E        +  where False = <function isfile at 0x7fe07c452dc0>('/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv')
E        +    where <function isfile at 0x7fe07c452dc0> = <module 'posixpath' from '/usr/lib/python3.8/posixpath.py'>.isfile
E        +      where <module 'posixpath' from '/usr/lib/python3.8/posixpath.py'> = os.path
E        +    and   '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv' = <function get_rural_csv_fp at 0x7fe07b281d30>()
E        +      where <function get_rural_csv_fp at 0x7fe07b281d30> = <module 'lwserialization.rural' from '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/lwserialization/rural.py'>.get_rural_csv_fp

tests/test_all.py:6: AssertionError
________________________________ test_load_file ________________________________

    def test_load_file():
        from lwserialization import rural
        import pandas
>       assert type(rural.load_rural_csv()) == type(pandas.DataFrame([])), "the loaded file isn't a pandas.DataFrame"

tests/test_all.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lwserialization/rural.py:27: in load_rural_csv
    return pandas.read_csv(get_rural_csv_fp())
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:680: in read_csv
    return _read(filepath_or_buffer, kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:575: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:933: in __init__
    self._engine = self._make_engine(f, self.engine)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine
    self.handles = get_handle(  # type: ignore[call-overload]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path_or_buf = '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'
mode = 'r'

    @doc(compression_options=_shared_docs["compression_options"] % "path_or_buf")
    def get_handle(
        path_or_buf: FilePath | BaseBuffer,
        mode: str,
        *,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -> IOHandles[str] | IOHandles[bytes]:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        {compression_options}
    
            .. versionchanged:: 1.0.0
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.
    
            .. versionchanged:: 1.4.0 Zstandard support.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # validate encoding and errors
        codecs.lookup(encoding)
        if isinstance(errors, str):
            codecs.lookup_error(errors)
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[BaseBuffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        # Only for write methods
        if "r" not in mode and is_path:
            check_parent_directory(str(handle))
    
        if compression:
            if compression != "zstd":
                # compression libraries do not like an explicit text-mode
                ioargs.mode = ioargs.mode.replace("t", "")
            elif compression == "zstd" and "b" not in ioargs.mode:
                # python-zstandard defaults to text mode, but we always expect
                # compression libraries to use binary mode.
                ioargs.mode += "b"
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    # error: Incompatible types in assignment (expression has type
                    # "GzipFile", variable has type "Union[str, BaseBuffer]")
                    handle = gzip.GzipFile(  # type: ignore[assignment]
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # No overload variant of "GzipFile" matches argument types
                        # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                        fileobj=handle,  # type: ignore[call-overload]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                # No overload variant of "BZ2File" matches argument types
                # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                handle = bz2.BZ2File(  # type: ignore[call-overload]
                    handle,
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                # error: Argument 1 to "_BytesZipFile" has incompatible type "Union[str,
                # BaseBuffer]"; expected "Union[Union[str, PathLike[str]],
                # ReadBuffer[bytes], WriteBuffer[bytes]]"
                handle = _BytesZipFile(
                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]
                )
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file()(handle, ioargs.mode)
    
            # Zstd Compression
            elif compression == "zstd":
                zstd = import_optional_dependency("zstandard")
                if "r" in ioargs.mode:
                    open_args = {"dctx": zstd.ZstdDecompressor(**compression_args)}
                else:
                    open_args = {"cctx": zstd.ZstdCompressor(**compression_args)}
                handle = zstd.open(
                    handle,
                    mode=ioargs.mode,
                    **open_args,
                )
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
>               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'

/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/common.py:789: FileNotFoundError
_________________________________ test_columns _________________________________

    def test_columns():
        from lwserialization import rural
>       assert rural.explore_columns() == 67, "wrong number of columns"

tests/test_all.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lwserialization/rural.py:35: in explore_columns
    dataset = load_rural_csv()
lwserialization/rural.py:27: in load_rural_csv
    return pandas.read_csv(get_rural_csv_fp())
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:680: in read_csv
    return _read(filepath_or_buffer, kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:575: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:933: in __init__
    self._engine = self._make_engine(f, self.engine)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine
    self.handles = get_handle(  # type: ignore[call-overload]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path_or_buf = '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'
mode = 'r'

    @doc(compression_options=_shared_docs["compression_options"] % "path_or_buf")
    def get_handle(
        path_or_buf: FilePath | BaseBuffer,
        mode: str,
        *,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -> IOHandles[str] | IOHandles[bytes]:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        {compression_options}
    
            .. versionchanged:: 1.0.0
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.
    
            .. versionchanged:: 1.4.0 Zstandard support.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # validate encoding and errors
        codecs.lookup(encoding)
        if isinstance(errors, str):
            codecs.lookup_error(errors)
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[BaseBuffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        # Only for write methods
        if "r" not in mode and is_path:
            check_parent_directory(str(handle))
    
        if compression:
            if compression != "zstd":
                # compression libraries do not like an explicit text-mode
                ioargs.mode = ioargs.mode.replace("t", "")
            elif compression == "zstd" and "b" not in ioargs.mode:
                # python-zstandard defaults to text mode, but we always expect
                # compression libraries to use binary mode.
                ioargs.mode += "b"
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    # error: Incompatible types in assignment (expression has type
                    # "GzipFile", variable has type "Union[str, BaseBuffer]")
                    handle = gzip.GzipFile(  # type: ignore[assignment]
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # No overload variant of "GzipFile" matches argument types
                        # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                        fileobj=handle,  # type: ignore[call-overload]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                # No overload variant of "BZ2File" matches argument types
                # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                handle = bz2.BZ2File(  # type: ignore[call-overload]
                    handle,
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                # error: Argument 1 to "_BytesZipFile" has incompatible type "Union[str,
                # BaseBuffer]"; expected "Union[Union[str, PathLike[str]],
                # ReadBuffer[bytes], WriteBuffer[bytes]]"
                handle = _BytesZipFile(
                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]
                )
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file()(handle, ioargs.mode)
    
            # Zstd Compression
            elif compression == "zstd":
                zstd = import_optional_dependency("zstandard")
                if "r" in ioargs.mode:
                    open_args = {"dctx": zstd.ZstdDecompressor(**compression_args)}
                else:
                    open_args = {"cctx": zstd.ZstdCompressor(**compression_args)}
                handle = zstd.open(
                    handle,
                    mode=ioargs.mode,
                    **open_args,
                )
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
>               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'

/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/common.py:789: FileNotFoundError
__________________________________ test_size ___________________________________

    def test_size():
        from lwserialization import rural
>       assert rural.explore_size() == 266, "wrong dataset size"

tests/test_all.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lwserialization/rural.py:45: in explore_size
    dataset = load_rural_csv()
lwserialization/rural.py:27: in load_rural_csv
    return pandas.read_csv(get_rural_csv_fp())
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:680: in read_csv
    return _read(filepath_or_buffer, kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:575: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:933: in __init__
    self._engine = self._make_engine(f, self.engine)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine
    self.handles = get_handle(  # type: ignore[call-overload]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path_or_buf = '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'
mode = 'r'

    @doc(compression_options=_shared_docs["compression_options"] % "path_or_buf")
    def get_handle(
        path_or_buf: FilePath | BaseBuffer,
        mode: str,
        *,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -> IOHandles[str] | IOHandles[bytes]:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        {compression_options}
    
            .. versionchanged:: 1.0.0
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.
    
            .. versionchanged:: 1.4.0 Zstandard support.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # validate encoding and errors
        codecs.lookup(encoding)
        if isinstance(errors, str):
            codecs.lookup_error(errors)
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[BaseBuffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        # Only for write methods
        if "r" not in mode and is_path:
            check_parent_directory(str(handle))
    
        if compression:
            if compression != "zstd":
                # compression libraries do not like an explicit text-mode
                ioargs.mode = ioargs.mode.replace("t", "")
            elif compression == "zstd" and "b" not in ioargs.mode:
                # python-zstandard defaults to text mode, but we always expect
                # compression libraries to use binary mode.
                ioargs.mode += "b"
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    # error: Incompatible types in assignment (expression has type
                    # "GzipFile", variable has type "Union[str, BaseBuffer]")
                    handle = gzip.GzipFile(  # type: ignore[assignment]
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # No overload variant of "GzipFile" matches argument types
                        # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                        fileobj=handle,  # type: ignore[call-overload]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                # No overload variant of "BZ2File" matches argument types
                # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                handle = bz2.BZ2File(  # type: ignore[call-overload]
                    handle,
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                # error: Argument 1 to "_BytesZipFile" has incompatible type "Union[str,
                # BaseBuffer]"; expected "Union[Union[str, PathLike[str]],
                # ReadBuffer[bytes], WriteBuffer[bytes]]"
                handle = _BytesZipFile(
                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]
                )
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file()(handle, ioargs.mode)
    
            # Zstd Compression
            elif compression == "zstd":
                zstd = import_optional_dependency("zstandard")
                if "r" in ioargs.mode:
                    open_args = {"dctx": zstd.ZstdDecompressor(**compression_args)}
                else:
                    open_args = {"cctx": zstd.ZstdCompressor(**compression_args)}
                handle = zstd.open(
                    handle,
                    mode=ioargs.mode,
                    **open_args,
                )
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
>               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'

/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/common.py:789: FileNotFoundError
________________________________ test_countries ________________________________

    def test_countries():
        from lwserialization import rural
>       assert rural.explore_countries() == 266, "wrong number of countries"

tests/test_all.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lwserialization/rural.py:55: in explore_countries
    dataset = load_rural_csv()
lwserialization/rural.py:27: in load_rural_csv
    return pandas.read_csv(get_rural_csv_fp())
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:680: in read_csv
    return _read(filepath_or_buffer, kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:575: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:933: in __init__
    self._engine = self._make_engine(f, self.engine)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine
    self.handles = get_handle(  # type: ignore[call-overload]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path_or_buf = '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'
mode = 'r'

    @doc(compression_options=_shared_docs["compression_options"] % "path_or_buf")
    def get_handle(
        path_or_buf: FilePath | BaseBuffer,
        mode: str,
        *,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -> IOHandles[str] | IOHandles[bytes]:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        {compression_options}
    
            .. versionchanged:: 1.0.0
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.
    
            .. versionchanged:: 1.4.0 Zstandard support.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # validate encoding and errors
        codecs.lookup(encoding)
        if isinstance(errors, str):
            codecs.lookup_error(errors)
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[BaseBuffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        # Only for write methods
        if "r" not in mode and is_path:
            check_parent_directory(str(handle))
    
        if compression:
            if compression != "zstd":
                # compression libraries do not like an explicit text-mode
                ioargs.mode = ioargs.mode.replace("t", "")
            elif compression == "zstd" and "b" not in ioargs.mode:
                # python-zstandard defaults to text mode, but we always expect
                # compression libraries to use binary mode.
                ioargs.mode += "b"
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    # error: Incompatible types in assignment (expression has type
                    # "GzipFile", variable has type "Union[str, BaseBuffer]")
                    handle = gzip.GzipFile(  # type: ignore[assignment]
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # No overload variant of "GzipFile" matches argument types
                        # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                        fileobj=handle,  # type: ignore[call-overload]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                # No overload variant of "BZ2File" matches argument types
                # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                handle = bz2.BZ2File(  # type: ignore[call-overload]
                    handle,
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                # error: Argument 1 to "_BytesZipFile" has incompatible type "Union[str,
                # BaseBuffer]"; expected "Union[Union[str, PathLike[str]],
                # ReadBuffer[bytes], WriteBuffer[bytes]]"
                handle = _BytesZipFile(
                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]
                )
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file()(handle, ioargs.mode)
    
            # Zstd Compression
            elif compression == "zstd":
                zstd = import_optional_dependency("zstandard")
                if "r" in ioargs.mode:
                    open_args = {"dctx": zstd.ZstdDecompressor(**compression_args)}
                else:
                    open_args = {"cctx": zstd.ZstdCompressor(**compression_args)}
                handle = zstd.open(
                    handle,
                    mode=ioargs.mode,
                    **open_args,
                )
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
>               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'

/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/common.py:789: FileNotFoundError
_______________________________ test_to_parquet ________________________________

    def test_to_parquet():
        from lwserialization import rural
>       df = rural.load_rural_csv()

tests/test_all.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lwserialization/rural.py:27: in load_rural_csv
    return pandas.read_csv(get_rural_csv_fp())
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/util/_decorators.py:311: in wrapper
    return func(*args, **kwargs)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:680: in read_csv
    return _read(filepath_or_buffer, kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:575: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:933: in __init__
    self._engine = self._make_engine(f, self.engine)
/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/parsers/readers.py:1217: in _make_engine
    self.handles = get_handle(  # type: ignore[call-overload]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path_or_buf = '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'
mode = 'r'

    @doc(compression_options=_shared_docs["compression_options"] % "path_or_buf")
    def get_handle(
        path_or_buf: FilePath | BaseBuffer,
        mode: str,
        *,
        encoding: str | None = None,
        compression: CompressionOptions = None,
        memory_map: bool = False,
        is_text: bool = True,
        errors: str | None = None,
        storage_options: StorageOptions = None,
    ) -> IOHandles[str] | IOHandles[bytes]:
        """
        Get file handle for given path/buffer and mode.
    
        Parameters
        ----------
        path_or_buf : str or file handle
            File path or object.
        mode : str
            Mode to open path_or_buf with.
        encoding : str or None
            Encoding to use.
        {compression_options}
    
            .. versionchanged:: 1.0.0
               May now be a dict with key 'method' as compression mode
               and other keys as compression options if compression
               mode is 'zip'.
    
            .. versionchanged:: 1.1.0
               Passing compression options as keys in dict is now
               supported for compression modes 'gzip', 'bz2', 'zstd' and 'zip'.
    
            .. versionchanged:: 1.4.0 Zstandard support.
    
        memory_map : bool, default False
            See parsers._parser_params for more information.
        is_text : bool, default True
            Whether the type of the content passed to the file/buffer is string or
            bytes. This is not the same as `"b" not in mode`. If a string content is
            passed to a binary file/buffer, a wrapper is inserted.
        errors : str, default 'strict'
            Specifies how encoding and decoding errors are to be handled.
            See the errors argument for :func:`open` for a full list
            of options.
        storage_options: StorageOptions = None
            Passed to _get_filepath_or_buffer
    
        .. versionchanged:: 1.2.0
    
        Returns the dataclass IOHandles
        """
        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior
        encoding = encoding or "utf-8"
    
        # read_csv does not know whether the buffer is opened in binary/text mode
        if _is_binary_mode(path_or_buf, mode) and "b" not in mode:
            mode += "b"
    
        # validate encoding and errors
        codecs.lookup(encoding)
        if isinstance(errors, str):
            codecs.lookup_error(errors)
    
        # open URLs
        ioargs = _get_filepath_or_buffer(
            path_or_buf,
            encoding=encoding,
            compression=compression,
            mode=mode,
            storage_options=storage_options,
        )
    
        handle = ioargs.filepath_or_buffer
        handles: list[BaseBuffer]
    
        # memory mapping needs to be the first step
        handle, memory_map, handles = _maybe_memory_map(
            handle,
            memory_map,
            ioargs.encoding,
            ioargs.mode,
            errors,
            ioargs.compression["method"] not in _compression_to_extension,
        )
    
        is_path = isinstance(handle, str)
        compression_args = dict(ioargs.compression)
        compression = compression_args.pop("method")
    
        # Only for write methods
        if "r" not in mode and is_path:
            check_parent_directory(str(handle))
    
        if compression:
            if compression != "zstd":
                # compression libraries do not like an explicit text-mode
                ioargs.mode = ioargs.mode.replace("t", "")
            elif compression == "zstd" and "b" not in ioargs.mode:
                # python-zstandard defaults to text mode, but we always expect
                # compression libraries to use binary mode.
                ioargs.mode += "b"
    
            # GZ Compression
            if compression == "gzip":
                if is_path:
                    assert isinstance(handle, str)
                    # error: Incompatible types in assignment (expression has type
                    # "GzipFile", variable has type "Union[str, BaseBuffer]")
                    handle = gzip.GzipFile(  # type: ignore[assignment]
                        filename=handle,
                        mode=ioargs.mode,
                        **compression_args,
                    )
                else:
                    handle = gzip.GzipFile(
                        # No overload variant of "GzipFile" matches argument types
                        # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                        fileobj=handle,  # type: ignore[call-overload]
                        mode=ioargs.mode,
                        **compression_args,
                    )
    
            # BZ Compression
            elif compression == "bz2":
                # No overload variant of "BZ2File" matches argument types
                # "Union[str, BaseBuffer]", "str", "Dict[str, Any]"
                handle = bz2.BZ2File(  # type: ignore[call-overload]
                    handle,
                    mode=ioargs.mode,
                    **compression_args,
                )
    
            # ZIP Compression
            elif compression == "zip":
                # error: Argument 1 to "_BytesZipFile" has incompatible type "Union[str,
                # BaseBuffer]"; expected "Union[Union[str, PathLike[str]],
                # ReadBuffer[bytes], WriteBuffer[bytes]]"
                handle = _BytesZipFile(
                    handle, ioargs.mode, **compression_args  # type: ignore[arg-type]
                )
                if handle.mode == "r":
                    handles.append(handle)
                    zip_names = handle.namelist()
                    if len(zip_names) == 1:
                        handle = handle.open(zip_names.pop())
                    elif len(zip_names) == 0:
                        raise ValueError(f"Zero files found in ZIP file {path_or_buf}")
                    else:
                        raise ValueError(
                            "Multiple files found in ZIP file. "
                            f"Only one file per ZIP: {zip_names}"
                        )
    
            # XZ Compression
            elif compression == "xz":
                handle = get_lzma_file()(handle, ioargs.mode)
    
            # Zstd Compression
            elif compression == "zstd":
                zstd = import_optional_dependency("zstandard")
                if "r" in ioargs.mode:
                    open_args = {"dctx": zstd.ZstdDecompressor(**compression_args)}
                else:
                    open_args = {"cctx": zstd.ZstdCompressor(**compression_args)}
                handle = zstd.open(
                    handle,
                    mode=ioargs.mode,
                    **open_args,
                )
    
            # Unrecognized Compression
            else:
                msg = f"Unrecognized compression type: {compression}"
                raise ValueError(msg)
    
            assert not isinstance(handle, str)
            handles.append(handle)
    
        elif isinstance(handle, str):
            # Check whether the filename is to be opened in binary mode.
            # Binary mode does not support 'encoding' and 'newline'.
            if ioargs.encoding and "b" not in ioargs.mode:
                # Encoding
>               handle = open(
                    handle,
                    ioargs.mode,
                    encoding=ioargs.encoding,
                    errors=errors,
                    newline="",
                )
E               FileNotFoundError: [Errno 2] No such file or directory: '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'

/home/selim/.cache/pypoetry/virtualenvs/d3-setup-Ms_lFR2R-py3.8/lib/python3.8/site-packages/pandas/io/common.py:789: FileNotFoundError
_______________________________ test_parquetted ________________________________

    def test_parquetted():
        from lwserialization import rural
>       assert os.path.isfile(rural.get_rural_csv_fp().replace(".csv", ".parquet")), "data/API-rural.parquet is not found"
E       AssertionError: data/API-rural.parquet is not found
E       assert False
E        +  where False = <function isfile at 0x7fe07c452dc0>('/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.parquet')
E        +    where <function isfile at 0x7fe07c452dc0> = <module 'posixpath' from '/usr/lib/python3.8/posixpath.py'>.isfile
E        +      where <module 'posixpath' from '/usr/lib/python3.8/posixpath.py'> = os.path
E        +    and   '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.parquet' = <built-in method replace of str object at 0x7fe06a38fb30>('.csv', '.parquet')
E        +      where <built-in method replace of str object at 0x7fe06a38fb30> = '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv'.replace
E        +        where '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/data/API-rural.csv' = <function get_rural_csv_fp at 0x7fe07b281d30>()
E        +          where <function get_rural_csv_fp at 0x7fe07b281d30> = <module 'lwserialization.rural' from '/home/selim/code/data-engineering-solutions/01-Data-Storage-and-Batch-Pipelines/03-NoSQL/02-Serialization/lwserialization/rural.py'>.get_rural_csv_fp

tests/test_all.py:45: AssertionError
=========================== short test summary info ============================
FAILED tests/test_all.py::test_there_is_a_csv_file - AssertionError: file API...
FAILED tests/test_all.py::test_load_file - FileNotFoundError: [Errno 2] No su...
FAILED tests/test_all.py::test_columns - FileNotFoundError: [Errno 2] No such...
FAILED tests/test_all.py::test_size - FileNotFoundError: [Errno 2] No such fi...
FAILED tests/test_all.py::test_countries - FileNotFoundError: [Errno 2] No su...
FAILED tests/test_all.py::test_to_parquet - FileNotFoundError: [Errno 2] No s...
FAILED tests/test_all.py::test_parquetted - AssertionError: data/API-rural.pa...
========================= 7 failed, 1 passed in 0.87s ==========================
