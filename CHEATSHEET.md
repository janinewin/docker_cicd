# Cheatsheet üí°

Below you'll find a bunch of pre-requisite and useful knowledge for the bootcamp.

## Tips on any linux command ‚ùì

You're wondering what `cat`, `make`, `wget` do and how to use them?

Two tools to the rescue, pre-installed on your servers:
- Type `tldr tar` to get info about the `tar` command. That's [tldr](https://tldr.sh/).
- Or type `man tar` to get the "official", but more old school manual.

## Download a file to the Virtual Machine üìÅ

Either **directly download the file**, for that

- In your browser, right click and "Copy link address" to get the URL
- Use `wget` to download the file: open a terminal and type `wget -O <name for the file> <url>`. For more information and examples, use `tldr wget`.

Or by downloading it to your laptop then copying it over to the virtual machine.
- Download it on your laptop, as you usually do, or use `wget` as described above üëÜ.
- Copy it to the server with `scp -i <path to your private SSH key> /path/to/the/file <username on the VM>@<VM IP>:/path/on/the/vm`. For instance:
  - My SSH key is located at `~/.ssh/id_rsa`
  - I've downloaded the file on my machine at `~/Downloads/some-file.txt`
  - On the server, my username is `joe` and IP is 33.442.44.112
  - I'd like to copy it to `/home/joe/hello/world/` on the server (this folder must already exist)
  - I'll do üëâ - `ssh -i ~/.ssh/id_rsa ~/Downloads/some-file.txt joe@33.442.44.112:/home/joe/hello/world/some-file.txt`

## Managing Python libraries in your projects with Poetry üìÉ

Python3 is installed by default on your system. For our work, we install additional Python packages. Let's imagine that we have 2 projects going on, one depends on [Protobuf v4.21.1](https://pypi.org/project/protobuf/) and the other on an older version [Protobuf v3.15.8](https://pypi.org/project/protobuf/3.15.8/).

We've got a **few problems**:
1. We'd like to work on the same computer for both projects, but they both need incompatible dependencies. How do we solve this?
2. We'd like to set the exact list of dependencies for reproducible builds on any other machine
3. Ideally it's all easy to use, and we manage as little as possible by hand

Thankfully, these are all **solved problems**:

### By hand

üôÜ‚Äç‚ôÇÔ∏è [Pip](https://pip.pypa.io/en/stable/) is the Python package installer. You'd install the required version of Protobuf with Pip.

üôÜ‚Äç‚ôÇÔ∏è `pip freeze` is the command to export the complete list of required dependencies. Typically you'd do `pip freeze > requirements.txt` to store this list in a file named `requirements.txt`.

üôÜ‚Äç‚ôÇÔ∏è [Virtual environments](https://docs.python.org/3/tutorial/venv.html) come to the rescue. A virtual environment is literally a copy of Python in a dedicated folder. Working within your virtual environment won't "pollute" the rest of your system. It is best practice to always work within a virtual environment. This requires to manually "activate" virtual environments when you switch from one project to another.

The combination of tools above works but it's not super easy is it? So we've simplified things for you, read on.

### Breathe with Poetry + Direnv

üôÜ‚Äç‚ôÄÔ∏è [Poetry](https://python-poetry.org/) is a modern Python packaging and dependency management. Please read the [basic usage](https://python-poetry.org/docs/basic-usage/) instructions. Poetry will:
- Create virtual environments for you
  - Create and install it with `poetry install`
  - Use it by simply prefixing your commands with `poetry run ...`. For instance `poetry run python some_file.py`
- Ensure reproducible builds by storing the equivalent of `requirements.txt` for you in 2 files:
  - `pyproject.toml` where YOU specify your dependencies and configuration
  - `poetry.lock` automatically generated by Poetry when running `poetry install`
- And even more, like packaging, publishing to Pypi etc.

üôÜ‚Äç‚ôÄÔ∏è [Direnv](https://direnv.net/). Wouldn't it be nice if we just `cd` to a directory (ie. moved in the terminal) and the right virtual environment is automatically picked up? Yes! We've done it for you. In your `zsh` shell, if you just `cd` to an exercise, you'll see `direnv` telling you it's using the right Poetry virtual environment. Now you don't need to use `poetry run python some_file.py`, you can just do `python some_file.py` and our setup will figure things out for you.

**In summary**, we've explained above how your bootcamp has been setup. What you really need to know is: **you don't have to worry about it üå¥**, just `cd` to an exercise and any `python` related command you run will pick the right configuration.

### Within Docker

- Install Poetry with `pip3 install poetry`
- Copy your code, most importantly the `poetry.lock` and `pyproject.toml`
- Run `poetry install`
- Prefix commands with `poetry run ...`

## Makefile üîÉ

You'll notice there are `Makefile` in each of the exercises' directory. Here's a good [primer on Makefile](https://ocw.mit.edu/courses/1-124j-foundations-of-software-engineering-fall-2000/pages/lecture-notes/makefile_primer/) if you're interested.

Essentially, the `make <command>` command looks for a `Makefile` file in the directory it's run, and a `<command>: ...` task in it. If found, the commands in that block will be run.

Try running
- `make install`: will install the Poetry packages for you (should already be done)
- `make test`: to run all Pytest tests

Pro note: there is a `make.inc` file at the root of the repository, which is included in all subsequent `Makefile`. This avoid copy/pasting this same code everywhere!

### PHONY?

By default, targets correspond to the name of a file. For instance if you run `make say-hi`, `make` will look for a file named `say-hi`. But not if you add `.PHONY: say-hi` above your target. It's a bit of a strange an unelegant terminology, but it's good practice. This explains why you'll find a lot of `.PHONY` in our Makefiles.

## Tests üö´

Tests are written with [Pytest](https://docs.pytest.org/en/7.1.x/). Each test should be under a `tests/` directory. We've added a `test:` command in all Makefile which executes Pytest for you, prints its output to the terminal in color (red is "not good", green is "happy"), and stores it to a `test_output.txt` file.

‚ö†Ô∏è This `test_output.txt` file is then used by Kitt to track your progress, be sure to `git add ...` it, commit and push it when you've made progress on a given exercise. Good luck with making your tests pass ‚òòÔ∏è!

### How to read the output of `make test`.

- when it passes `tests/test_all.py::test_csv PASSED`
- when there are errors, look at the end for the `short test summary info` then go back up for details
```======================================================= short test summary info ========================================================
FAILED tests/test_all.py::test_csv - AssertionError: file ratings.csv not found under data/
```

## Manage your VM

- Navigate to the [cloud instances](https://console.cloud.google.com/compute/).
- Turn on your VM every morning by selecting its checkbox ‚úÖ, clicking on the three dots, then "Start / Resume"
- Turn it off every evening by selecting its checkbox ‚úÖ, clicking on the three dots, then "Stop". That'll save money and energy.

## VSCode

### Main commands

Here is a cheatsheet
- For [Windows](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)
- For [MacOS](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf)
- For [Linux](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf)

The most important ones are:
- Show Command Palette
- Find (in current file)
- Show Search (across all files)
- Show integrated terminal (you'll constantly have a terminal open)

### How to open a port and connect to your apps and databases from your machine

When running apps / databases on your server, you typically access them using ports (5432 for Postgres, 8080 for Jupyter, 3000 for some apps, etc.). Now, these ports are protected by the server's firewall by default so you can't access them, even by going to `http://<server ip>:<port>` in the browser.

There's a simple solution though, directly integrated with VSCode (thanks VSCode).
- Open your terminal in VSCode
- Make sure you're connected to the server of course! No point running this on your machine.
- You'll see a tab `PORTS`, click on it
- Click the button `Forward a port`
- Add an entry in the table

For instance, let's say I have an app on the server running on port 3000 and you'd like it forwarded to your local port 3001. Type `3000` in the first column, and `3001` in the second.

In the browser, going to `http://localhost:3001` will forward the requests to the server's port 3000. Magic! It's called SSH tunneling and is done nicely for you by VSCode.

Note: you don't need to give the local port a different number, that was just for demo purposes.

### VSCode - Select the correct "Python interpreter"

In your exercise's directory, type `which python` to get the path to the right Python for the exercise, previously installed for you. In VSCode, open the commande palette, type `Python: Select interpreter` and then paste the path from `which python`. This will ensure the autocomplete works as expected.

For the best possible experience, click `File > Add folder to workspace` and only add the specific exercise's folder instead of the entire bootcamp repo. This will make VSCode's life easier, when trying to figure out which project you're working on.

## Configuration through environment variables

### Environment variables

To share secrets and/or configuration values, it's better to not store them in code.

What's better between the 2 snippets?

```python
# Scenario 1

password = "abcd"
def do_something():
    call_database(password=password)
```

and

```python
# Scenario 2

import os

def do_something():
    password = os.environ["PASSWORD"]
    call_database(password=password)
```

Scenario 2 is much better!

1. Do not store passwords in code, otherwise anyone accessing your code will have access to them. Use a password / secrets manager for that.
2. What if the password changes? You need to change the code, instead of re-running it with a different configuration.

In scenario 2, we use what's called an environment variable. It's a variable managed by the operating system and not the program, that you can pass to your program by either doing

```bash
export PASSWORD=abcd
python my_program.py
```

or directly

```bash
PASSWORD=abcd python my_program.py
```

It's recommended you use environment variables for configuration and passwords.

### Configuration files with `.env`

In Docker Compose, when you see the use of variable prefixed by a dollar sign, like `$POSTGRES_PASSWORD`, this means the `docker-compose` command will use an environment variable named `POSTGRES_PASSWORD`. Because there can be many such configuration variables, `docker-compose` will look for their values in a `.env` file (note that `.env` has been added to the root `.gitignore` so they won't ever be committed).

It's therefore good practice to create a `.env` file next to the `docker-compose.yml` file, and store the configuration variables / password in there, in the format `KEY=VALUE`.

For instance, we'd create a `.env` file with contents

```
POSTGRES_PASSWORD=abcd
```

which `docker-compose` will then be able to pick up.

To read more about how Docker Compose works with environment variables, check [this article](https://docs.docker.com/compose/environment-variables/).

To make your life easier, we've created `env-template` files, with contain the environment variables keys, but not the values. Copy these files into a `.env` (`cp env-template .env`) and fill out the right hand side (ie. the values).

For instance, we'd have

`env-template`
```
POSTGRES_PASSWORD=
```

and we expect you to create a `.env` file filled out from the template.
```
POSTGRES_PASSWORD=abcd
```

### Load `.env` into Python

In the `common/lewagonde` Python library, we've added a function `def load_dot_env(dot_env_fp: str)` which takes the path to a `.env` file as input, and loads its values into environment variables for you. This mimics the behaviour of Docker Compose in your Python programs, if you need.

## Permissions

If you encounter an error like this

```
find: ‚Äò./01-Data-Storage-and-Batch-Pipelines/04-ETL-and-introduction-to-Airflow/03-Local-ETL/database/pg_multixact‚Äô: Permission denied
```

this means you've created a directory owned by `root` (system administrator) and not the user you're logged in with. We've added a little helper method in the top `Makefile` to help you fix such issues. When you run this `make` target, all files within your repo will be owned by your user.

Go to the top of your git repository and run `make own-repo`.
