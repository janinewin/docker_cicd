# Cheatsheet üí°

Below you'll find a bunch of pre-requisite and useful knowledge for the bootcamp.

# 1Ô∏è‚É£ Managing Python libraries with Poetry üìÉ

Python3 is installed by default on your system. For our work, we install additional Python packages. Let's imagine that we have 2 projects going on, one depends on [Protobuf v4.21.1](https://pypi.org/project/protobuf/) and the other on an older version [Protobuf v3.15.8](https://pypi.org/project/protobuf/3.15.8/).

We've got a **few problems**:
1. We'd like to work on the same computer for both projects, but they both need incompatible dependencies. How do we solve this?
2. We'd like to set the exact list of dependencies for reproducible builds on any other machine
3. Ideally it's all easy to use, and we manage as little as possible by hand

Thankfully, these are all **solved problems**:

## By hand

üôÜ‚Äç‚ôÇÔ∏è [Pip](https://pip.pypa.io/en/stable/) is the Python package installer. You'd install the required version of Protobuf with Pip.

üôÜ‚Äç‚ôÇÔ∏è `pip freeze` is the command to export the complete list of required dependencies. Typically you'd do `pip freeze > requirements.txt` to store this list in a file named `requirements.txt`.

üôÜ‚Äç‚ôÇÔ∏è [Virtual environments](https://docs.python.org/3/tutorial/venv.html) come to the rescue. A virtual environment is literally a copy of Python in a dedicated folder. Working within your virtual environment won't "pollute" the rest of your system. It is best practice to always work within a virtual environment. This requires to manually "activate" virtual environments when you switch from one project to another.

The combination of tools above works but it's not super easy is it? So we've simplified things for you, read on.

## Poetry + Direnv

üôÜ‚Äç‚ôÄÔ∏è [Poetry](https://python-poetry.org/) is a modern Python packaging and dependency management. Please read the [basic usage](https://python-poetry.org/docs/basic-usage/) instructions. Poetry will:
- Create virtual environments for you
  - Create and install it with `poetry install`
  - Use it by simply prefixing your commands with `poetry run ...`. For instance `poetry run python some_file.py`
- Ensure reproducible builds by storing the equivalent of `requirements.txt` for you in 2 files:
  - `pyproject.toml` where YOU specify your dependencies and configuration
  - `poetry.lock` automatically generated by Poetry when running `poetry install`
- And even more, like packaging, publishing to Pypi etc.

üôÜ‚Äç‚ôÄÔ∏è [Direnv](https://direnv.net/). Wouldn't it be nice if we just `cd` to a directory (ie. moved in the terminal) and the right virtual environment is automatically picked up? Yes! We've done it for you. In your `zsh` shell, if you just `cd` to an exercise, you'll see `direnv` telling you it's using the right Poetry virtual environment. Now you don't need to use `poetry run python some_file.py`, you can just do `python some_file.py` and our setup will figure things out for you.

**In summary**, we've explained above how your bootcamp has been setup. What you really need to know is: **you don't have to worry about it üå¥**, just `cd` to an exercise and any `python` related command you run will pick the right configuration.

## Within Docker

- Install Poetry with `pip3 install poetry`
- Copy your code, most importantly the `poetry.lock` and `pyproject.toml`
- Run `poetry install`
- Prefix commands with `poetry run ...`


# 2Ô∏è‚É£ Makefile

You'll notice there are `Makefile` in each of the exercises' directory. Here's a good [primer on Makefile](https://ocw.mit.edu/courses/1-124j-foundations-of-software-engineering-fall-2000/pages/lecture-notes/makefile_primer/) if you're interested.

Essentially, the `make <command>` command looks for a `Makefile` file in the directory it's run, and a `<command>: ...` task in it. If found, the commands in that block will be run.

There is a `make.inc` file at the root of the repository, which is included in all subsequent `Makefile`. This avoids copy/pasting this same code everywhere!

Try running
- `make install`: will install the Poetry packages for you (should already be done)
- `make test`: to run all pytest tests and save outputs


## .PHONY?

By default, targets correspond to the name of a file. For instance if you run `make say-hi`, `make` will look for a file named `say-hi`. But not if you add `.PHONY: say-hi` above your target. It's a bit of a strange and unelegant terminology, but it's good practice. This explains why you'll find a lot of `.PHONY` in our Makefiles.

## Tests üö´

Tests are written with [Pytest](https://docs.pytest.org/en/7.1.x/). Each test should be under a `tests/` directory. We've added a `test:` command in all Makefile which executes Pytest for you, prints its output to the terminal in color (red is "not good", green is "happy"), and stores it to a `test_output.txt` file.

‚ö†Ô∏è This `test_output.txt` file is then used by Kitt to track your progress, be sure to `git add ...` it, commit and push it when you've made progress on a given exercise. Good luck with making your tests pass ‚òòÔ∏è!

## How to read the output of `make test`.

- when it passes `tests/test_all.py::test_csv PASSED`
- when there are errors, look at the end for the `short test summary info` then go back up for details
```======================================================= short test summary info ========================================================
FAILED tests/test_all.py::test_csv - AssertionError: file ratings.csv not found under data/
```

# 3Ô∏è‚É£ VSCode

## Main commands

Here is a cheatsheet
- For [Windows](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)
- For [MacOS](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf)
- For [Linux](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf)

The most important ones are:
- Show Command Palette
- Find (in current file)
- Show Search (across all files)
- Show integrated terminal (you'll constantly have a terminal open)

## How to open a port and connect to your apps and databases from your machine

When running apps / databases on your server, you typically access them using ports (5432 for Postgres, 8080 for Jupyter, 3000 for some apps, etc.). Now, these ports are protected by the server's firewall by default so you can't access them, even by going to `http://<server ip>:<port>` in the browser.

There's a simple solution though, directly integrated with VSCode (thanks VSCode).
- Open your terminal in VSCode
- Make sure you're connected to the server of course! No point running this on your machine.
- You'll see a tab `PORTS`, click on it
- Click the button `Forward a port`
- Add an entry in the table

For instance, let's say I have an app on the server running on port 3000 and you'd like it forwarded to your local port 3001. Type `3000` in the first column, and `3001` in the second.

In the browser, going to `http://localhost:3001` will forward the requests to the server's port 3000. Magic! It's called SSH tunneling and is done nicely for you by VSCode.

Note: you don't need to give the local port a different number, that was just for demo purposes.

<img src="https://wagon-public-datasets.s3.amazonaws.com/data-engineering/W0D1/port-forwarding-vscode.png" width=400>

## Select the correct "Python interpreter"

In your exercise's directory, type `which python` to get the path to the right Python for the exercise, previously installed for you. In VSCode, open the commande palette, type `Python: Select interpreter` and then paste the path from `which python`. This will ensure the autocomplete works as expected.

<img src="https://wagon-public-datasets.s3.amazonaws.com/data-engineering/vs-code-select-interpreter.png" width=400>

You may have noticed that it works automatically if you open VScode exactly at the challenge root. It's because we setup for you the following parameters in your VSCode settings (have a look and try to find it)
```json
{
  ...
  "python.defaultInterpreterPath": ".venv/bin/python",
  ...
}
```

# 4Ô∏è‚É£ Linux

## glob patterns

Pattern matching file very useful in linux (For `.gitignore`, `.dockerignore`, `git add "<glob_pattern>"` etc...)

**Examples**
- `foo`  (files or folder `foo`, at root or any sub-directory) Equivalent to  `**/foo`
- `/foo` (file or folder `foo`, at root-level only)

- `foo/`  (folder `foo`, at root or any sub-directory)
- `/foo/` (folder `foo`, at root-level only)

Usual cases
- `.env`  (all .env files or folders anywhere)
- `*.csv` (all files ending with .csv anywhere)

**Rules**
- If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular `.gitignore` file itself
  - Otherwise the pattern may also match at any level below the `.gitignore` level.
- The character "`?`" matches any **one** character except "`/`"
- An asterisk "`*`" matches anything except a slash
- A leading "`**/` means match in all directories. e.g `**/abc`
- A trailing "`/**`" matches everything inside.

## Permissions

If you encounter an error like this

```
find: './database/pg_multixact': Permission denied
```

this means you've created a directory owned by `root` (system administrator) and not the user you're logged in with. We've added a little helper method in the top `Makefile` to help you fix such issues. When you run this `make` target, all files within your repo will be owned by your user.

Go to the top of your git repository and run `make own-repo`.


# 5Ô∏è‚É£ Configuration through environment variables

To share secrets and/or configuration values, it's better to not store them in code.

What's better between the 2 snippets?

```python
# Scenario 1

password = "abcd"
def do_something():
    call_database(password=password)
```

and

```python
# Scenario 2

import os

def do_something():
    password = os.environ["PASSWORD"]
    call_database(password=password)
```

Scenario 2 is much better!

1. Do not store passwords in code, otherwise anyone accessing your code will have access to them. Use a password / secrets manager for that.
2. What if the password changes? You need to change the code, instead of re-running it with a different configuration.

In scenario 2, we use what's called an environment variable. It's a variable managed by the operating system and not the program, that you can pass to your program by either doing

```bash
export PASSWORD=abcd
python my_program.py
```

or directly

```bash
PASSWORD=abcd python my_program.py
```

It's recommended you use environment variables for configuration and passwords.

## Configuration files with `.env`

In Docker Compose, when you see the use of variable prefixed by a dollar sign, like `$POSTGRES_PASSWORD`, this means the `docker-compose` command will use an environment variable named `POSTGRES_PASSWORD`. Because there can be many such configuration variables, `docker-compose` will look for their values in a `.env` file (note that `.env` has been added to the root `.gitignore` so they won't ever be committed).

It's therefore good practice to create a `.env` file next to the `docker-compose.yml` file, and store the configuration variables / password in there, in the format `KEY=VALUE`.

For instance, we'd create a `.env` file with contents

```
POSTGRES_PASSWORD=abcd
```

which `docker-compose` will then be able to pick up.

To read more about how Docker Compose works with environment variables, check [this article](https://docs.docker.com/compose/environment-variables/).

To make your life easier, we've created `env-template` files, with contain the environment variables keys, but not the values. Copy these files into a `.env` (`cp env-template .env`) and fill out the right hand side (ie. the values).

For instance, we'd have

`env-template`
```
POSTGRES_PASSWORD=
```

and we expect you to create a `.env` file filled out from the template.
```
POSTGRES_PASSWORD=abcd
```

## Load `.env` into Python

In the `common/lewagonde` Python library, we've added a function `def load_dot_env(dot_env_fp: str)` which takes the path to a `.env` file as input, and loads its values into environment variables for you. This mimics the behaviour of Docker Compose in your Python programs, if you need.


# 6Ô∏è‚É£ Manage your VM

## Start/stop

```bash
gcloud compute instances list # CHECK YOU VM STATUS

gcloud compute instances start <your_vm_name>
gcloud compute instances stop <your_vm_name>
```

OR:
- Navigate to the [cloud instances](https://console.cloud.google.com/compute/).
- Turn on your VM every morning by selecting its checkbox ‚úÖ, clicking on the three dots, then "Start / Resume"
- Turn it off every evening by selecting its checkbox ‚úÖ, clicking on the three dots, then "Stop". That'll save money and energy.

## Download a file to the Virtual Machine üìÅ

Either **directly download the file**, for that

- In your browser, right click and "Copy link address" to get the URL
- Use `wget` to download the file: open a terminal and type `wget -O <name for the file> <url>`. For more information and examples, use `tldr wget`.

Or by downloading it to your laptop then copying it over to the virtual machine.
- Download it on your laptop, as you usually do, or use `wget` as described above üëÜ.
- Copy it to the server with `scp -i <path to your private SSH key> /path/to/the/file <username on the VM>@<VM IP>:/path/on/the/vm`. For instance:
  - üëâ `ssh -i ~/.ssh/id_rsa ~/Downloads/some-file.txt joe@33.442.44.112:/home/joe/hello/world/some-file.txt`
  - My SSH key is located at `~/.ssh/id_rsa`
  - I've downloaded the file on my machine at `~/Downloads/some-file.txt`
  - On the server, my username is `joe` and IP is 33.442.44.112
  - I'd like to copy it to `/home/joe/hello/world/` on the server (this folder must already exist)


## Networking / Port mapping

When you write code on your server, in particular when you use databases or write web apps that expose a port, it won't be directly accessible on your machine as the server blocks access to these ports to the external port thanks to its firewall.

There are simple ways to "forward" the server ports to your machine ports, using VSCode port forwarding feature when using VSCode on your remote server. See the section "How to open a port and connect to your apps and databases from your machine" in the cheatsheet, or VSCode's [official doc](https://code.visualstudio.com/docs/remote/ssh#_forwarding-a-port-creating-ssh-tunnel).

Additionally, when your services are packaged in a Docker container, Docker (and Docker Compose) create an additional network within your server: the Docker network. In the same fashion, the Docker container ports are not directly accessible from the server's ports table. To access Docker container ports in your server, you'll need to add a `ports:` section to your `docker-compose.yml` file, to map the `server port:container port`.

Below is a diagram summing up and explaining the two levels of ports mapping you'll need to master throughout the bootcamp.

![Port mapping explained](https://storage.googleapis.com/lewagon-data-engineering-bootcamp-assets/assets/Ports.drawio.png)

### Error proxy: listen tcp4 0.0.0.0:xxx: bind: "address already in use"
It often comes from a previous challenge's container that wasn't correctly removed.

```bash
# First, check what's running on that port
sudo ss -lptn 'sport = :5432'  # e.g. users:(("postgres",pid=790,fd=3))
# Then, you can kill this process if you are sure
sudo kill 790
```

### Blank page on localhost:xxxx without error messages
First check if port-forwarding is well activated in VScode "port" tab on your VM.
If still doesn't fix it, it may be an backlog of badly closed port-forwarding that you need to kill manually:
- check on your local machine what's running on this specific xxxx port you try to get
  ```bash
  # Mac os
  lsof -i tcp:xxx

  # linux
  sudo ss -lptn 'sport = :xxx'
  ```
- if you see something that starts as below It can be an old connexion that you can kill manually with `kill 6679`
  ```
  Code\x20H 6679 .... (CLOSED)
  ```
- Try again to forward port on your VM-VScode and see if that's better, rebooting VScode too.
- If none of this work, port-forward via command line in your local machine

  ```bash
  # On your local machine (not your VM)
  ssh -L xxx:localhost:xxx <vm_IP_address>
  ```

# 7Ô∏è‚É£ DEBUGGING üêõ

Here are some options, from basic & quick to fancy & heavy:

- basic: `print()` statements
- interactive CLI: `breakpoint()`
- interactive CLI with syntax: `import ipdb; ipdb.set_trace()`
- VS Code debugger: (click on line number to add a "red dot"), then "Debug python file"
- VS Code "Jupyter Run Selection/Line in Interactive Window" --> Open a Notebook-like interactive session.
- Standalone jupyter notebook and import your code

## Adding breakpoint inside a running docker container ?

Add `breakpoint()` in your code base. Then:

#### With docker

```bash
docker run --it <your_image>
```

#### With docker-compose:
Add the following to your docker-compose.yml file

```yml
my_service_name:
  <...>
  stdin_open: true # eq. to docker run -i
  tty: true        # eq. to docker run -t
```

then

```bash
docker-compose up
docker attach <running_container_id>
```
